// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: parrot_missions_ophtalmo_airsdk_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// All the steps (in order) of the calibration process
enum Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStep: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case idle // = 0
  case takeoff // = 1
  case takeoffDone // = 2
  case ascending // = 3
  case ascendingDone // = 4
  case turning // = 5
  case turningDone // = 6
  case descending // = 7
  case descendingDone // = 8
  case landing // = 9
  case landingDone // = 10
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .takeoff
    case 2: self = .takeoffDone
    case 3: self = .ascending
    case 4: self = .ascendingDone
    case 5: self = .turning
    case 6: self = .turningDone
    case 7: self = .descending
    case 8: self = .descendingDone
    case 9: self = .landing
    case 10: self = .landingDone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .takeoff: return 1
    case .takeoffDone: return 2
    case .ascending: return 3
    case .ascendingDone: return 4
    case .turning: return 5
    case .turningDone: return 6
    case .descending: return 7
    case .descendingDone: return 8
    case .landing: return 9
    case .landingDone: return 10
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStep: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStep] = [
    .idle,
    .takeoff,
    .takeoffDone,
    .ascending,
    .ascendingDone,
    .turning,
    .turningDone,
    .descending,
    .descendingDone,
    .landing,
    .landingDone,
  ]
}

#endif  // swift(>=4.2)

enum Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case idle // = 0
  case inProgress // = 1
  case ok // = 2
  case ko // = 3
  case aborted // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .inProgress
    case 2: self = .ok
    case 3: self = .ko
    case 4: self = .aborted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .inProgress: return 1
    case .ok: return 2
    case .ko: return 3
    case .aborted: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStatus] = [
    .idle,
    .inProgress,
    .ok,
    .ko,
    .aborted,
  ]
}

#endif  // swift(>=4.2)

struct Parrot_Missions_Ophtalmo_Airsdk_Messages_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Altitude (above ground level) at which the calibration will be done.
  /// If 0 is given, the drone will use a default altitude (120m).
  var altitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Parrot_Missions_Ophtalmo_Airsdk_Messages_State {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calibrationStatus: Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStatus = .idle

  var calibrationStep: Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStep = .idle

  var completionPercent: UInt32 = 0

  var config: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config {
    get {return _config ?? Parrot_Missions_Ophtalmo_Airsdk_Messages_Config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config? = nil
}

/// Union of all possible commands of this package.
struct Parrot_Missions_Ophtalmo_Airsdk_Messages_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Parrot_Missions_Ophtalmo_Airsdk_Messages_Command.OneOf_ID? = nil

  /// Start calibration (drone will automatically takeoff if needed).
  var start: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config {
    get {
      if case .start(let v)? = id {return v}
      return Parrot_Missions_Ophtalmo_Airsdk_Messages_Config()
    }
    set {id = .start(newValue)}
  }

  /// Abort calibration (drone will stop moving)
  var abort: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .abort(let v)? = id {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {id = .abort(newValue)}
  }

  /// Reset last known status. Only allowed when step is idle
  var resetStatus: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .resetStatus(let v)? = id {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {id = .resetStatus(newValue)}
  }

  /// Start calibration (drone will automatically takeoff if needed).
  /// It will to a hand takeoff procedure instead of a normal one
  var startHand: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config {
    get {
      if case .startHand(let v)? = id {return v}
      return Parrot_Missions_Ophtalmo_Airsdk_Messages_Config()
    }
    set {id = .startHand(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    /// Start calibration (drone will automatically takeoff if needed).
    case start(Parrot_Missions_Ophtalmo_Airsdk_Messages_Config)
    /// Abort calibration (drone will stop moving)
    case abort(SwiftProtobuf.Google_Protobuf_Empty)
    /// Reset last known status. Only allowed when step is idle
    case resetStatus(SwiftProtobuf.Google_Protobuf_Empty)
    /// Start calibration (drone will automatically takeoff if needed).
    /// It will to a hand takeoff procedure instead of a normal one
    case startHand(Parrot_Missions_Ophtalmo_Airsdk_Messages_Config)

  #if !swift(>=4.1)
    static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Command.OneOf_ID, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Command.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.start, .start): return {
        guard case .start(let l) = lhs, case .start(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.abort, .abort): return {
        guard case .abort(let l) = lhs, case .abort(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resetStatus, .resetStatus): return {
        guard case .resetStatus(let l) = lhs, case .resetStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startHand, .startHand): return {
        guard case .startHand(let l) = lhs, case .startHand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Union of all possible events of this package.
struct Parrot_Missions_Ophtalmo_Airsdk_Messages_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Parrot_Missions_Ophtalmo_Airsdk_Messages_Event.OneOf_ID? = nil

  var state: Parrot_Missions_Ophtalmo_Airsdk_Messages_State {
    get {
      if case .state(let v)? = id {return v}
      return Parrot_Missions_Ophtalmo_Airsdk_Messages_State()
    }
    set {id = .state(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ID: Equatable {
    case state(Parrot_Missions_Ophtalmo_Airsdk_Messages_State)

  #if !swift(>=4.1)
    static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Event.OneOf_ID, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Event.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.state, .state): return {
        guard case .state(let l) = lhs, case .state(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "parrot.missions.ophtalmo.airsdk.messages"

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStep: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALIBRATION_STEP_IDLE"),
    1: .same(proto: "CALIBRATION_STEP_TAKEOFF"),
    2: .same(proto: "CALIBRATION_STEP_TAKEOFF_DONE"),
    3: .same(proto: "CALIBRATION_STEP_ASCENDING"),
    4: .same(proto: "CALIBRATION_STEP_ASCENDING_DONE"),
    5: .same(proto: "CALIBRATION_STEP_TURNING"),
    6: .same(proto: "CALIBRATION_STEP_TURNING_DONE"),
    7: .same(proto: "CALIBRATION_STEP_DESCENDING"),
    8: .same(proto: "CALIBRATION_STEP_DESCENDING_DONE"),
    9: .same(proto: "CALIBRATION_STEP_LANDING"),
    10: .same(proto: "CALIBRATION_STEP_LANDING_DONE"),
  ]
}

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_CalibrationStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CALIBRATION_STATUS_IDLE"),
    1: .same(proto: "CALIBRATION_STATUS_IN_PROGRESS"),
    2: .same(proto: "CALIBRATION_STATUS_OK"),
    3: .same(proto: "CALIBRATION_STATUS_KO"),
    4: .same(proto: "CALIBRATION_STATUS_ABORTED"),
  ]
}

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config) -> Bool {
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "calibration_status"),
    2: .standard(proto: "calibration_step"),
    3: .standard(proto: "completion_percent"),
    4: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.calibrationStatus) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.calibrationStep) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.completionPercent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.calibrationStatus != .idle {
      try visitor.visitSingularEnumField(value: self.calibrationStatus, fieldNumber: 1)
    }
    if self.calibrationStep != .idle {
      try visitor.visitSingularEnumField(value: self.calibrationStep, fieldNumber: 2)
    }
    if self.completionPercent != 0 {
      try visitor.visitSingularUInt32Field(value: self.completionPercent, fieldNumber: 3)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_State, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_State) -> Bool {
    if lhs.calibrationStatus != rhs.calibrationStatus {return false}
    if lhs.calibrationStep != rhs.calibrationStep {return false}
    if lhs.completionPercent != rhs.completionPercent {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "abort"),
    3: .standard(proto: "reset_status"),
    4: .standard(proto: "start_hand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .start(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .abort(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .abort(v)
        }
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .resetStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .resetStatus(v)
        }
      }()
      case 4: try {
        var v: Parrot_Missions_Ophtalmo_Airsdk_Messages_Config?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .startHand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .startHand(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .start?: try {
      guard case .start(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .abort?: try {
      guard case .abort(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .resetStatus?: try {
      guard case .resetStatus(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .startHand?: try {
      guard case .startHand(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Command, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Command) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Parrot_Missions_Ophtalmo_Airsdk_Messages_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Parrot_Missions_Ophtalmo_Airsdk_Messages_State?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .state(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .state(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .state(let v)? = self.id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Event, rhs: Parrot_Missions_Ophtalmo_Airsdk_Messages_Event) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
